---
title: 最短路径算法——Floyd算法
date: 2017-03-20 16:35:26
categories: Algorithm
tags: [Algorithm]
keywords: Algorithm
toc: true
---


* 本文对最短路径算法——Floyd算法进行介绍和归纳。


<!--more-->

## Floyd-Warshall Algorithm
### 基本介绍
> Floyd-Warshall 算法，简称为Floyd算法，即弗洛伊德算法，是解决任意两点间的最短路径的一种算法，可以正确处理有向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。--- [维基百科](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95)
>

Floyd算法的时间复杂度为`O(n^3)`。常见的算法形式为

```cpp
void Floyd(){
	int i,j,k;
	for(k=1;k<=n;k++){
		for(i=1;i<=n;i++){
			for(j=1;j<=n;j++){
				if(dist[i][k]+dist[k][j]<dist[i][j]){
					dist[i][j]=dist[i][k]+dist[k][j];
				}
			}	
		}
	}
}
```


### 使用算法的条件
可以正确处理有向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。
 

### 原理
Floyd-Warshall 算法的原理是动态规划。

设 `Di,j,k`为从`i`到`j`的只以`(1..k)`集合中的节点为中间节点的最短路径的长度。
* 若最短路径经过点`k`，则 `Di,j,k = Di,k,k-1 + Dk,j,k-1`。
* 若最短路径不经过点`k`，则 `Di,j,k = Di,j,k-1`

因此，`Di,j,k =min(Di,j,k-1, Di,k,k-1 + Dk,j,k-1)`。在实际算法中，为了节约空间，可以直接在原来空间上进行迭代，这样空间可降至二维。


## 应用实例：多源最短路径问题
下面将针对具体实例，讲解Floyd算法的原理。

![floyd-1.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-1.jpg)
暑假，小哼准备去一些城市旅游。有些城市之间有公路，有些城市之间则没有，如下图所示。为了节省经费以及方便计划旅程，小哼希望在出发之前知道任意两个城市之前的最短路程。

![floyd-2.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-2.jpg)

上图中有4个城市8条公路，公路上的数字表示这条公路的长短。请注意这些公路是单向的。我们现在需要求任意两个城市之间的最短路程，也就是求任意两个点之间的最短路径。这个问题这也被称为**多源最短路径**问题。

现在需要一个数据结构来存储图的信息，我们仍然可以用一个4*4的矩阵（二维数组e）来存储。比如1号城市到2号城市的路程为2，则设`e[1][2]`的值为2。2号城市无法到达4号城市，则设置`e[2][4]`的值为∞。另外此处约定一个城市自己是到自己的也是0，例如`e[1][1]`为0，具体如下所示。

![floyd-3.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-3.jpg)

现在回到问题：如何求任意两点之间最短路径呢？通过之前的学习我们知道通过深度或广度优先搜索可以求出两点之间的最短路径。所以进行`n^2`遍深度或广度优先搜索，即对每两个点都进行一次深度或广度优先搜索，便可以求得任意两点之间的最短路径。可是还有没有别的方法呢？

我们来想一想，根据我们以往的经验，**如果要让任意两点（例如从顶点a点到顶点b）之间的路程变短，只能引入第三个点（顶点k），并通过这个顶点k中转即`a->k->b`，才可能缩短原来从顶点a点到顶点b的路程。** 那么这个中转的顶点k是1~n中的哪个点呢？甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，即`a->k1->k2->b`或者`a->k1->k2…->ki->…->b`。比如上图中从4号城市到3号城市（4->3）的路程`e[4][3]`原本是12。如果只通过1号城市中转（4->1->3），路程将缩短为11（`e[4][1]+e[1][3]=5+6=11`）。其实1号城市到3号城市也可以通过2号城市中转，使得1号到3号城市的路程缩短为5（`e[1][2]+e[2][3]=2+3=5`）。所以如果同时经过1号和2号两个城市中转的话，从4号城市到3号城市的路程会进一步缩短为10。通过这个的例子，我们发现每个顶点都有可能使得另外两个顶点之间的路程变短。好，下面我们将这个问题一般化。

当任意两点之间不允许经过第三个点时，这些城市之间最短路程就是初始路程，如下。
![floyd-4.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-4.jpg)

如现在只允许经过1号顶点，求任意两点之间的最短路程，应该如何求呢？只需判断`e[i][1]+e[1][j]`是否比`e[i][j]`要小即可。`e[i][j]`表示的是从i号顶点到j号顶点之间的路程。`e[i][1]+e[1][j]`表示的是从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。其中i是1~n循环，j也是1~n循环，代码实现如下。

```cpp
for(i=1;i<=n;i++)   
{   
    for(j=1;j<=n;j++)   
    {   
		if ( e[i][j] > e[i][1]+e[1][j] ) {
			e[i][j] = e[i][1]+e[1][j]; 
		}    
    }   
} 
```

在只允许经过1号顶点的情况下，任意两点之间的最短路程更新为
![floyd-5.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-5.jpg)

通过上图我们发现：在只通过1号顶点中转的情况下，3号顶点到2号顶点（`e[3][2]`）、4号顶点到2号顶点（`e[4][2]`）以及4号顶点到3号顶点（`e[4][3]`）的路程都变短了。

接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短路程。如何做呢？我们需要**在只允许经过1号顶点时任意两点的最短路程的结果下**，再判断如果经过2号顶点是否可以使得i号顶点到j号顶点之间的路程变得更短。即判断`e[i][2]+e[2][j]`是否比`e[i][j]`要小，代码实现为如下。

```cpp
//经过1号顶点   
for(i=1;i<=n;i++)   
    for(j=1;j<=n;j++)   
		 if (e[i][j] > e[i][1]+e[1][j])  e[i][j]=e[i][1]+e[1][j];   
//经过2号顶点   
for(i=1;i<=n;i++)   
    for(j=1;j<=n;j++)   
		if (e[i][j] > e[i][2]+e[2][j])  e[i][j]=e[i][2]+e[2][j]; 
```
在只允许经过1和2号顶点的情况下，任意两点之间的最短路程更新为
![floyd-6.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-6.jpg)

通过上图得知，在相比只允许通过1号顶点进行中转的情况下，这里允许通过1和2号顶点进行中转，使得`e[1][3]`和`e[4][3]`的路程变得更短了。

同理，继续在只允许经过1、2和3号顶点进行中转的情况下，求任意两点之间的最短路程。任意两点之间的最短路程更新为
![floyd-7.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-7.jpg)

最后允许通过所有顶点作为中转，任意两点之间最终的最短路程为
![floyd-8.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-8.jpg)

整个算法过程虽然说起来很麻烦，但是代码实现却非常简单，**核心代码**只有五行，如下所示。

```cpp
for(k=1;k<=n;k++)   
    for(i=1;i<=n;i++)   
		 for(j=1;j<=n;j++)   
		     if(e[i][j]>e[i][k]+e[k][j])   
				   e[i][j]=e[i][k]+e[k][j]; 
```
上述核心代码的基本思想：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程，即`Di,j,k =min(Di,j,k-1, Di,k,k-1 + Dk,j,k-1)`。这是一种**动态规划**的思想。

需要注意的是，如何表示路径的无穷大。如果你认为正无穷和其它值相加得到一个大于正无穷的数是不被允许的话，我们只需在比较的时候加两个判断条件就可以了。

```cpp
//Floyd-Warshall算法核心语句   
for(k=1;k<=n;k++)   
  for(i=1;i<=n;i++)   
      for(j=1;j<=n;j++)   
		 if(e[i][k]<inf && e[k][j]<inf && e[i][j]>e[i][k]+e[k][j])   
		     e[i][j]=e[i][k]+e[k][j]; 
```
 

此处给出针对该问题的完整代码。（程序中不允许无穷大的权值加上其他一个数）

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	int k, i, j, n, m, t1, t2, t3;
	int inf = INT_MAX;    
	//读入n和m，n表示顶点个数，m表示边的条数   
	cin>>n>>m;
	vector<vector<int>> e(n+1,vector<int>(m+1,0));
	//初始化   
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= n; j++) {
			if (i == j) {
				e[i][j] = 0;
			}
			else {
				e[i][j] = inf;
			}
		}
	}
	
	//读入边   
	for (i = 1; i <= m; i++)
	{
		cin>>t1>>t2>>t3;
		e[t1][t2] = t3;
	}
	
	//Floyd-Warshall算法核心语句   
	for (k = 1; k <= n; k++) {
		for (i = 1; i <= n; i++) {
			for (j = 1; j <= n; j++) {
				if (( e[i][k] < inf) && (e[k][j] < inf) && (e[i][j] > e[i][k] + e[k][j])) {
					e[i][j] = e[i][k] + e[k][j];
				}
			}
		}
	}
	
	//输出最终的结果   
	for (i = 1; i <= n; i++)
	{
		for (j = 1; j <= n; j++)
		{
			cout <<"From "<<i<<" to "<<j<<" : "<< e[i][j] << endl;
		}		
	}
	system("pause");
	return 0;
}
```
上面代码的输入数据样式为

```
4 8   
1 2 2   
1 3 6   
1 4 4   
2 3 3   
3 1 7   
3 4 1   
4 1 5   
4 3 12 
```
第一行两个数为n和m，n表示顶点个数，m表示边的条数。
接下来m行，每一行有三个数t1、t2 和t3，表示顶点t1到顶点t2的路程是t3。
程序输出结果为
```
From 1 to 1 : 0
From 1 to 2 : 2
From 1 to 3 : 5
From 1 to 4 : 4
From 2 to 1 : 9
From 2 to 2 : 0
From 2 to 3 : 3
From 2 to 4 : 4
From 3 to 1 : 6
From 3 to 2 : 8
From 3 to 3 : 0
From 3 to 4 : 1
From 4 to 1 : 5
From 4 to 2 : 7
From 4 to 3 : 10
From 4 to 4 : 0
```
 数组表示最终结果如下。
![floyd-9.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-9.jpg)


### 易错点
* 注意程序中动态规划路径时，`Di,j,k =min(Di,j,k-1, Di,k,k-1 + Dk,j,k-1)`中是否允许无穷大权值加上一个其他数值。
* 上述程序中无穷大值采用了`INT_MAX`，如果此时再允许无穷大权值加上一个其它数值，则会产生溢出，造成求解错误。如果无穷值采用例如`99999999`等一个很大的数值，无穷大权值加上一个其它数值不会产生溢出的话，可以省略在Floyd核心算法中对路径是否为无穷大值的判断。
 
* Floyd算法不能处理带有**负权回路**的图。
Floyd-Warshall算法不能解决带有**负权回路**（或者叫负权环）的图，因为带有负权回路的图没有最短路。例如下面这个图就不存在1号顶点到3号顶点的最短路径。因为1->2->3->1->2->3->…->1->2->3这样路径中，每绕一次1->-2>3这样的环，最短路就会减少1，永远找不到最短路。其实如果一个图中带有负权回路，那么这个图则没有最短路。

![floyd-10.jpg](http://ol3kbaay9.bkt.clouddn.com/floyd-10.jpg)

##  网易2016笔试 - 比较重量
### 题目
* 小明陪小红去看钻石，他们从一堆钻石中随机抽取两颗并比较她们的重量。这些钻石的重量各不相同。在他们们比较了一段时间后，它们看中了两颗钻石g1和g2。现在请你根据之前比较的信息判断这两颗钻石的哪颗更重。
给定两颗钻石的编号g1,g2，编号从1开始，同时给定关系数组vector,其中元素为一些二元组，第一个元素为一次比较中较重的钻石的编号，第二个元素为较轻的钻石的编号。最后给定之前的比较次数n。请返回这两颗钻石的关系，若g1更重返回1，g2更重返回-1，无法判断返回0。输入数据保证合法，不会有矛盾情况出现。
* 测试样例：
2,3,[[1,2],[2,4],[1,3],[4,3]],4
返回: 1

### 分析
构造一个有向图（无权值），则该题目问题可以转换为判断是否有g1到g2的路径。采用Floyd算法求解。由于是无向图，因此，需要对Floyd算法进行必要的修改，若边的权值为1，则表示有边；若为0，则表示没有边。
 
```cpp
if ( dis[i][k] > 0 && dis[k][j] > 0) { 
	//若不等于0，则证明存在边
	dis[i][j] = dis[i][k] + dis[k][j];
}					
```
 
### 求解

```cpp
class Cmp {
public:
	int cmp(int g1, int g2, vector<vector<int> > records, int n) {
		int res = 0;
		//初始化
		int max_size = records[0][0];
		for (int i = 0; i < n; i++) {
			max_size = max(max_size, records[i][0]);
			max_size = max(max_size, records[i][1]);
		}
		vector<vector<int>> dis(max_size+1,vector<int>(max_size+1,0)); //初始化为0
		//读取边
		for (int i = 0; i < n; i++) {
			dis[records[i][0]][records[i][1]] = 1; //存在边，则赋值为1
		}
		//Floyd算法
		for (int k = 1; k <= max_size; k++) {
			for (int i = 1; i <= max_size; i++) {
				for (int j = 1; j <= max_size; j++) {
					if ( dis[i][k] > 0 && dis[k][j] > 0) { 
						//若不等于0，则证明存在边
						dis[i][j] = dis[i][k] + dis[k][j];
					}
				}
			}
		}
		//结果判断
		if (dis[g1][g2] != 0) {
			res = 1;
		}
		else if (dis[g2][g1] != 0) {
			res = -1;
		}
		return res;
	}
};
```

## 参考资料
[1] [坐在马桶上看算法：只有五行的Floyd最短路算法](http://developer.51cto.com/art/201403/433874.htm)


## 反馈与建议
- 邮箱：<lbs1203940926@163.com>
- 微信：[@脱缰的哈士奇(ab1203940926)](http://ojx8u3g1z.bkt.clouddn.com/wechat-id.jpg)
- 微博：[@脱缰的哈士](http://weibo.com/2329754491/profile) 