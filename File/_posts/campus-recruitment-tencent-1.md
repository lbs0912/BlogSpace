---
title: 腾讯2017前端实习生模拟试题
date: 2017-03-30 14:35:48
categories: 校招笔试编程题
tags: [校招笔试编程题,腾讯笔试]
keywords: 校招笔试编程题,腾讯笔试
---


* 本文主要对腾讯2017前端实习生模拟试题行记录。
* 考试时长1H，共有15道选择题，1道编程题和1道问答题。编程题只能提交答案，并进行输入输出测试，不进行AC判断。

<!--more-->



## 选择题1 - 子网掩码

IP地址为140.123.0.0的地址为B类地址，若要切割为10个子网，而且都连上Internet，请问子网掩码为多少？

### 解答
子网掩码为255.255.240.0。

B类地址默认的子网掩码是255.255.0.0，所以要划分出9个子网，那么应该从主机位划分出4位来表示，2^3<9<2^4。所以子网掩码设置为255.255.240.0。
（240=1111 0000）

> **子网的个数 = 2^m   (m表示从主机号中借用的位数)**
**主机个数 = (2^n)-2  (剩余的主机位数，减2是要减去广播地址和网络地址)**



## 选择题2 - 路由汇聚
设有2条路由21.1.193.0/24和21.1.194.0/24，如果进行路由汇聚，汇聚这两条路由的地址是（）

A、21.1.200.0/22
B、21.1.192.0/23
C、21.1.192.0/21
D、21.1.224.0/20

### 解答
* 正确答案：C
* 参考[路由汇聚 | 百度百科](http://baike.baidu.com/item/%E8%B7%AF%E7%94%B1%E6%B1%87%E8%81%9A)求解该题。

```
193 = 1100 0001
194 = 1100 0010
193和194的前6位相同，都是是1100 00XX，而1100 0000 = 192。
因此，网络号是8+8+6 = 22位。
综上，汇聚这两个路由的地址是21.1.200.0/22。

但是题目选项中并没有该答案。此时，要选择一个最佳答案。选项B的21.1.192.0/23无法包含所有的路由。选项C和D均可以包含该路由，但是选项C包含2^3种路由，选项D包含2^4种路由，选择最佳选项为C。
```


## 选择题3 - 二叉树遍历
一个二叉树，前序遍历是CABEFDHG，中序遍历是BAFECHDG，求后序遍历结果。

### 分析
* 二叉数遍历中的前序，中序和后序是指的根节点在前面，中间和后面访问，即是以根节点遍历的顺序为基准的。


* 二叉树前序遍历
	- 1、访问根节点
	- 2、前序遍历左子树
	- 3、前序遍历右子树

* 二叉树中序遍历（中序也称为对称序列）
	- 1、中序遍历左子树
	- 2、访问根节点
	- 3、中序遍历右子树

* 二叉树后序遍历
	- 1、后序遍历左子树 
	- 2、后序遍历右子树 
	- 3、访问根节点

* 二叉树层序遍历
	- 从上至下，逐层遍历二叉树 
	- 每一层中，从左到右遍历二叉树
	
### 解答
参考《大话数据结构》P185中的推导方法，画出草图求解。

![tree-1.jpg](http://ol3kbaay9.bkt.clouddn.com/tree-1.jpg)
![tree-2.jpg](http://ol3kbaay9.bkt.clouddn.com/tree-2.jpg)

最终树的结构如下图所示。因此后序遍历结果是BFEAHGDC。

![tree-1.jpg](http://ol3kbaay9.bkt.clouddn.com/tree-3.jpg)


## 选择题4 - 二叉树遍历
二叉树的节点的**对称序列**是ABCDEFG，后序序列是BDCAFGE，则该二叉树的前序序列是：

A、EGFACDB
B、EACBDGF
C、EAGCFBD
D、EGACDFB

### 解答
**二叉树中序遍历中，中序也称为对称序列。**
正确选项为B（EACBDGF）


## 选择题5 - 磁头调度算法
若磁头的当前位置在第100磁道，现在有一磁盘读写请求序列如下：23,376,205,132,19,61,190,398,29,4,18,40。若采用最短寻道时间优先算法，则平均寻道长度是多少？

### 解答
![enter image description here](http://ol3kbaay9.bkt.clouddn.com/sstf-4.PNG)

如上图所示，平均寻道长度是57.67。


## 选择题6 - 磁头调度算法
若干个等待访问磁盘者依次要访问的磁道为 19， 43， 40， 4， 79，11，76，当前磁头位于 40 号柱面，若用最短寻道时间优先磁盘调度算法，则访问序列为___
A、19,43,40,4,79,11,76
B、40,43,19,11,4,76,79
C、40,43,76,79,19,11,4
D、40,43,76,79,4,11,19
E、40,43,76,79,11,4,19
F、40,19,11,4,79,76,43

### 解答
正确答案为B。

最短寻道时间优先每次找离当前磁头最近的。


## 选择题7 - 操作系统
文件管理系统的最小磁盘单位是（）

A、扇区
B、页面
C、簇
D、文件

### 解答
正确答案是D（文件）。

![簇和扇区](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Disk-structure2.svg/600px-Disk-structure2.svg.png)

上图中，A是磁道，B是扇面，C是扇区，D是簇（扇区组）。

* **物理硬盘中扇区是磁盘最小的物理存储单元。**
* **簇（Data cluster）或者分配单元（Allocation Unit）是操作系统中磁盘文件存储管理的单位。**簇是一个或多个物理扇区组成的，具体由格式化时选定文件系统而定。**簇是操作系统所使用的逻辑概念，而非磁盘的物理特性。**
* 由于物理硬盘中扇区是磁盘最小的物理存储单元，扇区在硬盘中存在的量很大并且每个扇区都必须有编号，所以操作系统无法对数目众多的扇区进行寻址。因此操作系统将相邻的扇区组合在一起，组成簇这一单位用以高效率地利用资源。**文件系统是操作系统与硬盘驱动器之间的接口**，当系统请求从硬盘里读取一个文件时，会请求相应的文件系统打开文件，**簇包含的扇区数是由文件系统格式与分配单元大小而定**。一般每个簇可以包括2、4、8、16、32或64个扇区。
* **操作系统是以文件为单位对数据进行管理的。**
* **在计算机系统中，文件是最小的数据组织单位**。而硬盘则是存储文件的大容量存储设备。
* **文件是操作系统读取磁盘信息的基本单位**（因此本题选D，文件）。一个文件是磁盘上存储信息的一个集合。
* 参考阅读[文件管理系统](https://books.google.co.jp/books?id=tH1x2OAEaMoC&pg=PA19&lpg=PA19&dq=%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%B0%8F%E7%A3%81%E7%9B%98%E5%8D%95%E4%BD%8D%E6%98%AF%EF%BC%88%EF%BC%89&source=bl&ots=bU5XPDJvSq&sig=ciSNGOcXZO20GAdSnPg_htSQTHQ&hl=zh-CN&sa=X&ved=0ahUKEwi0w_qAj_bSAhWnsFQKHeMwDpIQ6AEIJzAB#v=onepage&q=%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%B0%8F%E7%A3%81%E7%9B%98%E5%8D%95%E4%BD%8D%E6%98%AF%EF%BC%88%EF%BC%89&f=false)和[数据结构](https://books.google.co.jp/books?id=H4oWNDJepH4C&pg=PA350&lpg=PA350&dq=%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%B0%8F%E7%A3%81%E7%9B%98%E5%8D%95%E4%BD%8D%E6%98%AF%EF%BC%88%EF%BC%89&source=bl&ots=OINQrCt9Vt&sig=6dGUPdDiE8BxyaYA9enZbcETohw&hl=zh-CN&sa=X&ved=0ahUKEwid6qCzj_bSAhXnjlQKHTbuCJIQ6AEILzAD#v=onepage&q=%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%80%E5%B0%8F%E7%A3%81%E7%9B%98%E5%8D%95%E4%BD%8D%E6%98%AF%EF%BC%88%EF%BC%89&f=false)了解该部分知识。

> 从应用程序的角度来看，存储信息的最小单位为字节Byte；从磁盘的物理结构来看，存储信息的最小单位为扇区（512字节）；从操作系统读取磁盘的角度来看，虽然扇区是磁盘最小的物理单元，但由于操作系统无法对数目众多的扇区进行寻址，因此操作系统将相邻的多个扇区连在一起视为簇，也就是说簇是操作系统使用的逻辑单位。**从操作系统对硬盘的存取管理来看，存取信息的最小单位是簇**，簇是一个逻辑概念，一个簇可以是2、4、8、16、32或64个连续的扇区。一个簇只能被一个文件占用，哪怕是只有1个字节的文件，在磁盘上存储时也要占用一个簇，这个簇里剩下的扇区是无用的。所以，**簇可以理解为磁盘存取信息的最小单位**（而不是**文件管理系统**中最小的磁盘单位）。 --- [2017腾讯windows开发笔试题](http://www.doc00.com/doc/100100iiy)



## 选择题8 - 程序输出

```
class X {
public:
	void xoo() {};
};

int main() {
	cout << sizeof(X) << endl;
	return 0;
}
```
程序输出结果是多少？

###  求解
程序输出结果：1。空类的sizeof结果是1。


## 选择题9 - 二分查找
 针对二分查找算法，假设一个有序数组有136个元素，那么要查找到第10个元素，需要比较的元素为

A、68,34,17,9,13,11,10
B、68,34,17,8,12,10
C、69,35,18,10
D、68,34,18,9,13,11,10

### 解答
正确答案是B。

数据编号1~136，若计算mid时候向下取整，则为68,34,17,8,12,10。若为向上取整，则为69,35,18,9,14,12,11,10。

> 给予一个包含n个带值元素的数组A或是记录A0 ... An−1，使得A0 ≤ ... ≤ An−1（即二分法使用前提是序列有序）以及目标值T，还有下列用来搜索T在A中位置的子程序。
> 1. 令L为0，R为n− 1。
> 2.  如果L > R，则搜索以失败告终。
> 3. 令m（中间值元素）为(L + R) / 2（向下取整）。
> 4. 如果Am < T，令L为m + 1并回到步骤二。
> 5. 如果Am > T，令R为m - 1并回到步骤二。
> 6. 当Am = T，搜索结束；回传值m。
> 
> 这个迭代步骤会持续通过两个变量追踪搜索的边界。有些实际应用会在算法的最后放入相等比较，让比较循环更快，但平均而言会多一层迭代。


## 选择题10 - 循环赛事
寝室有6个同学打dota，分为对立的两方，一方是天灾军团，一方是近卫军团。现请你设置赛程以及每场的对阵（每方最少1人、最多5人），请问至少得进行多少场比赛，才能使得赛程结束后每位同学都和其他同学做过对手（）

A. 2
B. 3
C. 4
D. 5

题目链接：[牛客网](https://www.nowcoder.com/questionTerminal/fabbfc1420174fa9b57f6fa1fcd54e69?orderByHotValue=0&questionTypes=110000&mutiTagIds=602&page=17&onlyReference=false)

### 解答
共需要3场。如下图所示。

![enter image description here](http://ol3kbaay9.bkt.clouddn.com/dota-1.PNG)

## 选择题11 - 概率
对于一副扑克牌，抽到黑色继续抽，抽到红色停止。平均下来，每次能抽几张？（也就是三国杀中甄姬的洛神技能，得到牌数的期望值）
A. 1
B. 1.2
C. 0.8
D. 0.9

题目链接：[牛客网](https://www.nowcoder.com/questionTerminal/6cecf1994aa4420facd65802b2fc6949?orderByHotValue=0&questionTypes=110000&mutiTagIds=602&page=17&onlyReference=false)

### 解答

参考资料：[数据统计 - 甄姬洛神摸牌期望值的计算](http://wangyou.pcgames.com.cn/zhuanti/sgs/exp/1108/2286876.html)

正确答案是A（1）。

**抽到黑色牌之后继续抽，表示黑色牌仍放入总扑克牌中，并不取出。**因此，每次抽牌，红色和黑色牌的数目都是相同的，每次抽中黑色牌的概率都是1/2。

抽中0张黑色牌概率：a0 = 1/2
抽中1张黑色牌概率：a1 = (1/2) * (1/2) = 1/4 =  (1/2)^(1+1)
抽中2张黑色牌概率：a2 = (1/2) * (1/2) * (1/2) = 1/8 =  (1/2)^(2+1)
抽中3张黑色牌概率：a3 = 1/16 = (1/2)^(3+1)

因此，抽中n张牌的概率为`an = (1/2)^(n+1)`。

则平均每次抽中牌的张数（即得到牌数的期望值）为
`Sn = 1*a1+2*a2+...+n*an = 1*(1/4)+2*(1/8)+...+n*(1/2)^(n+1)`

上式是一个差比数列求和问题。

```
Sn = 1*a1+2*a2+...+n*an = 1*(1/4)+2*(1/8)+...+n*(1/2)^(n+1)
(1/2)*Sn = 1*(1/8)+2*(1/16)+...+n*(1/2)^(n+1)+n*(1/2)^(n+2)
作差有，
(1/2)*Sn = (1/4)+(1/8)...+(1/2)^(n+1) - n*(1/2)^(n+2)  （使用等比数列求和公式求解）
(1/2)*Sn = (1/2) - (1/2)^(n+1) - n*(1/2)^(n+2)
最终得到，
Sn = 1 - (1/2)^(n) - n*(1/2)^(n+1)
Sn = 1 - (n+2)*(1/2)^(n+1)
```
因此，得到牌的期望值是`Sn = 1 - (n+2)*(1/2)^(n+1)`。当牌数很多的时候，期望值趋向于1。


## 选择题12 - 数字游戏
从1到2048的所有整数中1的出现的个数是（）
A. 1600
B. 1615
C. 1011
D. 1200


题目链接：[牛客网](https://www.nowcoder.com/questionTerminal/774903bffbc846ff8855a55fb24e7621?orderByHotValue=0&questionTypes=110000&mutiTagIds=602&page=17&onlyReference=false)

### 求解
正确答案是B（1615）

数字2048中， 
* 个位出现的1 = 204*1+1 = 205 
* 十位出现的1 = 20*10+10 = 210 
* 百位出现的1 = 2*100 = 200 
* 千位出现的1 = 0*1000+1000 = 1000

因此，一共出现的次数为205+210+200+1000 = 1615。

参考资料：[从1到n整数中1出现的次数 - O(logn)算法](http://blog.csdn.net/yi_afly/article/details/52012593)

代码实现如下。

```cpp
//C++
class Solution {
public:
    int countDigitOne(int n) {
        if(n<1){
            return 0;
        }
        int count = 0;
        int base = 1;
        int round = n;
        int weight;
        while(round>0){
            weight = round%10;
            round /= 10;
            count += round*base;
            if(weight == 1){
                count += (n%base)+1;
            }
            else if(weight > 1){
                count += base;
            }
            base *= 10;
        }
        return count;
    }
};
```


## 选择题13 - 数字游戏
从1到999999的所有整数中3的出现的个数是多少？
### 求解
参考[从1到n整数中1出现的次数 - O(logn)算法](http://blog.csdn.net/yi_afly/article/details/52012593)了解计算过程。

999999中，
* 个位出现的3 = 99,999*1+1 = 100,000
* 十位出现的3 = 9,999*10+10 = 100,000
* 百位出现的3 = 999*100+100 = 100,000
* 千位出现的3 = 99*1,000+1,000 = 100,000
* 万位出现的3 = 9*10,000+10,000 = 100,000
* 十万位出现的3 = 0*100,000+100,000 = 100,000

因此，数字3一共出现的次数为600,000。




## 选择题14 - 线性结构
以下哪些属于线性结构？

A、队列
B、栈
C、线性表
D、树
E、图

### 解答
正确答案：A,B,C

* 非线性结构：树，图，表，二维和多维数组，堆
* 线性结构：**线性表**，栈，队列，双队列，一维数组，串。
* 栈和队列是两种特殊的线性表
* 数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个后继。



## 选择题15 - 栈的考察
对于元素1,2,3,4,5,6,7，其进栈之后再出栈，则出栈的种类共有多少种？

### 解答
> **n个元素进栈，不限制出栈顺序，则出栈序列的种类数为`f(n) = (2n)!/(n!*(n+1)!)`。**
> --- 参考 [CSDN](http://blog.csdn.net/zyearn/article/details/7758716) 和[卡特兰数列Catalan | 维基百科](https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0)

采用上述卡特兰通项公式得，`f(7) = 14!/(7!*8!) = 429`


## 选择题16 - 程序输出

```javascript
function func(a,b){
	console.log(func.length);
}
func(); //2
func(1); //2
func(1,2); //2
func(1,2,3); //2
func(1,2,3,4); //2
```

程序输出多少？

### 解答
程序输出2，2，2,  2，2。

阅读[MDN - Function.length](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length)了解更多。

* `functionName.length`指明函数的形参个数。注意是形参个数，而不是实参个数。如上程序所示。
* JS中调用函数时，不会检查实际参数个数是否等于形参个数。若实参个数少于形参个数，则未传入的形参会被赋值为undefined。若实参个数多于形参个数，则多传入的实参会被忽略。
* `arguments.length`指明函数实际参数的个数，而不是形参的个数。这点和`functionName.length`不同。

```javascript
function func(a,b){
	console.log(func.length);   //形参个数 2
	console.log(arguments.length); //实参的个数
}
func(); //2 0
func(1); //2 1
func(1,2); //2 2
func(1,2,3); //2 3
func(1,2,3,4); //2 4
```

`functionName.length`指明函数的形参个数。需要注意的是，只统计第1个含有默认值形参之前的参数个数。(**Only parameters before the first one with a default value is counted**)

```javascript
(function func1(a,b,c){
	console.log(func1.length); //3
})();
(function func2(a,b=1,c){
	//only parameters before the first one 
	//with a default value is counted
	console.log(func2.length); //1
})();
```
* 引用数据类型Function的length值是1。

```javascript
console.log(Function.length); //1
console.log((function(...args) {}).length);  //0
// 0, rest parameter is not counted
```


## 选择题17 - 枚举类型

```cpp
enum etst {
	eparam1, //0
	eparam2, //1
	eparam3 = 10,
	eparam4,   //11
	eparam5 = 'a',  //97
	eparam6   //98
} epr;

cout<<eparam4<<eparam6<<endl;
```
求程序输出结果。a的ASCII值是97。

### 解答
程序输出结果是11和98。

> 如果枚举没有初始化，则从第一个标识符开始，依次赋给标识符0, 1, 2, ...。但当枚举中的某个成员赋值后，其后的成员按依次加1的规则确定其值。



## 选择题18 - 数组和指针

```cpp
int N = 10;
int M = 2;
int a[] = {2,1,4,3,6,5,8,7,10,9};
int (*b)[5] = (int(*)[5]) a;
for(int i=0;i<M;i++){
	for(int j=0;j<N/M;j++){
		cout<<b[i][j]<<endl;
	}
}
```
程序输出结果是多少？

### 解答
程序输出：2,1,4,3,6,5,8,7,10,9

参考[StackOverflow](http://stackoverflow.com/questions/43088010/c-arrary-point?noredirect=1#comment73257891_43088010)了解该知识点。

* C++中数组名指向数组的首地址。
程序中，`int a[] = {2,1,4,3,6,5,8,7,10,9};`表明a是一个一维数组。可以用`a[2]`的方式访问数组中的元素，当然，也可以采用`*(a+2)`的方式访问数组中的第3个元素，因为数组名指向数组的首地址。数组a在内存中存储格式如下所示。

```
     +---+---+---+---+---+---+---+---+---+---+
a -> | 2 | 1 | 4 | 3 | 6 | 5 | 8 | 7 | 10| 9 |;
     +---+---+---+---+---+---+---+---+---+---+
      +0  +1 ... 
```
* b是一个指向长度为5的数组的指针。
`int(*b)[5]`表明b是一个指向整型数组的指针，该数组的长度是5。 
`int(*b)[5] = (int(*)[5]) a;` 中在赋值时候进行了**强制类型转换**。由于a是一个数组，a和b的类型不同，若将其赋值给b，需要将其进行强制类型转换，而b的类型为`(int(*)[5])`。
同理，由于b是一个指针，因此`*b`指向数组a的起始位置，其长度为5，即`*b[0]`指向`a[0]~a[4]`。`b++`，即`b[1]`，则从`*b`指向的位置向后移动5个位置，指向`a[5]~a[9]`。

```
b[0] points to address a + 0
b[0][0] is the value of a + 0 or a[0] or *(a + 0)

b[1] points to address a + 5 
b[1][0] is the value of a + 5 or a[5] or *(a + 5)
```
* 综上，指针b就可以使用类似于二维数组的形式进行访问。

```cpp
b[0][0] = 2
b[0][1] = 1
b[0][2] = 4
b[0][3] = 3
b[0][4] = 6
b[1][0] = 5
b[1][1] = 8
b[1][2] = 7
b[1][3] = 10
b[1][4] = 9
```

* Effectively a is a 1x10 matrix and b is a 2x5 matrix, it is in fact a "reshape" of a into b, with the same content. The "most" dangerous thing here is that the reshape does not perform a deep copy, i.e., changes to b also affect a and vice versa.



## 选择题19  - 进程和子进程
在Linux上，对于多进程，子进程继承了父进程的下列哪些？

A、进程地址空间
B、共享内存
C、信号掩码
D、已打开的文件描述符
E、以上都不是

题目链接：[牛客网](https://www.nowcoder.com/questionTerminal/023e148777bc4a8db24ddbe4550285f9)

### 解答
* 正确答案是BCD
* 参考[CSDN Blog](http://blog.csdn.net/xiaojun111111/article/details/51764389)和[CSDN](http://blog.csdn.net/ygm_linux/article/details/50683877)了解更多。
* 子进程继承父进程
	- 用户号UIDs和用户组号GIDs
	- 环境Environment
	- 堆栈
	- 共享内存
	- 打开文件的描述符
	- 执行时关闭（Close-on-exec）标志
	- 信号（Signal）控制设定
	- 信号掩码
	- 进程组号
	- 当前工作目录
	- 根目录
	- 文件方式创建屏蔽字
	- 资源限制
	- 控制终端
* 子进程独有
	- 进程号PID
	- 不同的父进程号
	- 自己的文件描述符和目录流的拷贝
	- 子进程不继承父进程的进程正文（text），数据和其他锁定内存（memory locks）
	- 不继承异步输入和输出
	- 不继承父进程的文件锁，pending alarms和pending signals

* 父进程和子进程拥有独立的地址空间和PID参数。
* 子进程从父进程继承了用户号和用户组号，用户信息，目录信息，环境（表），打开的文件描述符，堆栈，（共享）内存等。
* 经过fork()以后，父进程和子进程拥有相同内容的代码段、数据段和用户堆栈，就像父进程把自己克隆了一遍。事实上，父进程只复制了自己的PCB块。而代码段，数据段和用户堆栈内存空间并没有复制一份，而是与子进程共享。只有当子进程在运行中出现写操作时，才会产生中断，并为子进程分配内存空间。由于父进程的PCB和子进程的一样，所以在PCB中断中所记录的父进程占有的资源，也是与子进程共享使用的。这里的“共享”一词意味着“竞争”

## 选择题20  - 进程和子进程
下面哪些属于，Fork后子进程保留了父进程的什么？
A、环境变量
B、父进程的文件锁，pending alarms和pending signals
C、当前工作目录
D、进程号

### 求解
正确答案是AC。

根据选择19 - 进程和子进程中的分析，很容易选出正确答案。

## 选择题21  - 线程
假设就绪队列中有10个线程，系统将时间片设置为200ms，CPU进行线程切换要花费10ms，则系统开销所占的比例约为
A、0.01
B、0.05
C、0.1
D、0.2
### 求解
正确答案是B（0.05）。

* 参考[操作系统的系统开销比率计算](https://www.zhihu.com/question/29209855/answer/43549181)了解更多。
* 操作系统调度耗时本身要算到时钟的时间片里。

![interval-1.PNG](http://ol3kbaay9.bkt.clouddn.com/interval-1.PNG)

上图的理解是错误的。因为操作系统调度耗时本身要算到时钟的时间片里。下图所示
的理解才是正确的。

![interval-2.PNG](http://ol3kbaay9.bkt.clouddn.com/interval-2.PNG)
* 操作系统的调度逻辑是：**发生中断->处理调度->发生中断->处理调度...**
* 一个时间片长度就是两次中断发生之间的间隔。因此，**系统开销比率 = 调度耗时/时间片长度**
* 本题中，系统开销比率 = 10/200 = 5% = 0.05


## 选择题22 - static考察

```cpp
int foo()
{
   static int x=3;
   x+=2;
   return x;
}
 
int main()
{
   cout<<foo()<<foo()<<endl;
}
```

上述程序输出结果是多少？

### 求解
* 程序输出75。
* static修饰变量时，如果有赋值，则会在程序开始时进行初始化工作，且**只操作一次**，如果没有赋值，系统会**自动赋初值0**。
* static变量和全局变量存储在**静态存储区**，静态局部变量可以保存上一次运行此模块的值。在整个程序运行期间，此空间不会被系统回收。
*  static定义的局部变量，在其定义的局部空间中可见，而其余位置不可见。其内存是在静态区，并初始化为0。
*  static定义的函数，只能在本文件中可见，其余空间不可见。
* **cout参数入栈的顺序是从右到左，编译器在解析的时候从右到左解析，最后cout结果输出时候执行出栈操作，即从左到右输出结果（符合栈的先进后出）。**
* 例如，`cout<<test1()<<" "<<test2()<<endl;`语句在执行的时候，参数入栈顺序是从右到左，先执行函数test2，并将其入栈。再执行函数test1，并将其入栈。cout执行输出的时候，函数test1先出栈，函数test2后出栈。
* 上述程序中，`cout<<foo()<<foo()<<endl;`先执行最右边的foo函数，此时static变量执行第1次也是唯一的1次初始化，函数执行结果是5，cout将结果5入栈。然后，再执行左边的foo函数，static初始化不在执行，x变量存储在静态存储区，上次执行的结果被保存，因此函数执行结果是7，cout将结果7入栈。执行cout输出的时候，按照出栈顺序执行，即从左向右输出结果。因此，最终语句输出75。

* 同理，结合cout参数的入栈和出栈，分析如下程序示例。


```cpp
//示例1
static int i = 3;
int test1(){
	return i++;
}
int test2(){
	return i+2;
}
int main()
{
    cout << test1() << " " << test2() << endl;  //3  5
}

//cout参数从右向左入栈，先执行test2(),返回(i+2) = 5，入栈。
//注意，此时i依旧是3。test2()函数只是返回i+2，并不是i = i+2。
//之后，执行test1()函数，i++是后加加，先返回i=3，将3入栈。之后，再将i加1。
//因此，程序输出结果是3 5。程序执行结束后，i等于4。


//示例2
static int i = 3;
int test1(){
	return ++i;
}
int test2(){
	i = i+2;
	return i;
}
int main()
{
    cout << test1() << " " << test2() << endl;  //6  5
}

//对比示例1,示例2程序输出结果是6 5
//cout参数从右向左入栈，先执行test2(),返回5，入栈。此时i=5
//之后，执行test1()函数，++i是前加加，对i先加1，再返回
//因此，程序输出结果是6 5。程序执行结束后，i等于6

```


## 编程题 - 质数对
### 题目
输入一个正数num，若num=A+B，并且A和B都是质数，则记为一个质数对。要求输出质数对的个数。例如，输入10，由于质数对为(5,5)和(3,7)，因此输出结果是2。

* 测试样例

```
输入： 10
输出： 2
```

### 分析
注意，判断一个数是否是质数时，对算法进行优化。
* 参考[LeetCode - 204. Count Primes ](https://github.com/lbs0912/LeetCode-Notes/blob/master/leetcode-notes-3.md#count-primes204)和[Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Algorithm_complexity)了解更多。
* 偶数中除了2之外，其余的偶数都不是质数。
* 质数判断中循环范围是从1到sqrt(num)。为了避免计算开方带来的性能损耗，可以使用`(i*i)<= num`代替。
* 排除了偶数之后，遍历从3开始。步进值设为2，可以节省一半的计算时间。

### 求解

```cpp
bool isPrime(int num) {
	if (num == 2) {
		return true;
	}
	if (num % 2 == 0) {
		//偶数中除了2之外，其他偶数都不是质数
		return false;
	}
	for (int i = 3; (i*i) <= num; i = i + 2) {
		//从3开始遍历，步进值为2（跳过偶数）
		if (num%i == 0) {
			return false;
		}
	}
	return true;
}

int main() {
	int num;
	int count;
	while (cin >> num) {
		count = 0;
		for (int i = 1; (i + i) <= num; i++) {
			if (isPrime(i) && isPrime(num - i)) {
				count++;
			}
		}
		cout << count << endl;
	}
	return 0;
}


```

## 问答题 - 楼层下落玻璃球
腾讯大厦有39层，你手里有两颗一模一样的玻璃珠。当你拿着玻璃珠在某一层往下扔的时候，一定会有两个结果，玻璃珠碎了或者没碎。大厦有个临界楼层，低于它的楼层，往下扔玻璃珠，玻璃珠不会碎，等于或高于它的楼层，扔下玻璃珠，玻璃珠一定会碎，玻璃珠碎了就不能再扔。现在让你设计一种方式，使得在该方式下，最坏的情况扔的次数比其他任何方式最坏的次数都少，也就是设计一种最有效的方式。

请给出正确答案，给出算法代码有加分。

### 求解
采用动态规划的思想求解。

初试问题为在39层中寻找临界层。若第1颗玻璃珠从第n层落下，若破碎，则第2颗珠子将从第1层逐层向上落下，最坏情况下，需要尝试n-1，再加上之前的1次，一共需要n次。若没碎，此时仍有2颗珠子，则问题转化为在39-N层中寻找临界层。

因此，N层楼如果从第n层落下第一颗玻璃珠，最坏的尝试次数是`max(n,1+F(N-n))`，其中F(i)表示在i层楼中寻找临界层最坏情况下的最小尝试次数。
上式即为**动态规划中的转移方程**。

综上，对于该问题的求解，其计算表达式为
`F(N) = min(max(1,1+F(N-1)), max(2,1+F(N-2)) ... max(N-1,1+F(N-(N-1)))`。初始条件为F(1) = 1。

```cpp
#include<iostream>
#include <algorithm>
#include <vector>
using namespace std;

int getMinCount(int floor) {
	vector<int> floors(floor+1, 0);
	floors[1] = 1;
	int temp;
	for (int i = 2; i <= floor; i++) {
		//对floors[i]赋初值
		//否则floors需要初始化为INT_MAX(使用climits头文件)
		floors[i] = max(1, 1 + floors[i - 1]);
		for (int j = 2; j < i; j++) {
			temp = max(j, 1 + floors[i - j]);
			if (temp < floors[i]) {
				floors[i] = temp;
			}
		}
	}
	return floors[floor];
}

int main()
{
	int dis = getMinCount(39);
	cout << dis << endl;
	//system("Pause");
	return 0;
}
```


对于39层楼，最坏情况下的尝试次数的最小值是9次。
* 第1次从第9层落下，若破碎，则从第1层逐层向上尝试。最坏情况下尝试次数为1+8=9。若第1次不破碎，转至下一步。
* 第2次从第9+8=17层落下。若破碎，则从第10层到第16层逐层尝试，需7次，再加上之前的2次，共9次。若不破碎，则转至下一步。
* 第3次从第9+8+7=24层落下。若破碎，则从第18层到第23层逐层尝试，需6次，再加上之前的3次，共9次。若不破碎，则转至下一步。
* 第4次从第9+8+7+6=30层落下。若破碎，则从第25层到第29层逐层尝试，需5次，再加上之前的4次，共9次。若不破碎，则转至下一步。
* 第5次从第9+8+7+6+5=35层落下。若破碎，则从第31层到第34层逐层尝试，需4次，再加上之前的5次，共9次。若不破碎，则转至下一步。
* 第6次从第9+8+7+6+5+4=39层落下。若破碎，则从第36层至第38层逐层尝试，需3次，再加上之前的6次，共9次。
* 从上述规律可以看出，若记最坏情况的最小尝试次数为n，则每次尝试的楼层数为第n层，第n+(n-1)层，第n+(n-1)+(n-2)层，第n+(n-1)+(n-2)+(n-3)层 ...... 第n+(n-1)+(n-2)+...+1层。


下面介绍该问题的非动态规划方法。下述方法不需要编程实现，**适用于面试环节**。

从上述规律可以发现
* 第1次抛下玻璃球的楼层必然是间隔最大的楼层。例如，第1次如果在m层抛下玻璃球，以后再抛玻璃球时的两次楼层就爱那个歌必然不大于m层。（反证法证明）
* 第2次抛下玻璃球的间隔楼层最优的选择必然比第1次间隔楼层少1层，即m-1；第3次抛下玻璃球的间隔楼层最优的选择必然比第2次间隔楼层少1层，即m-2；如此，以后每次抛棋子楼层间隔比上一次间隔少一层。

综上，设n是第一次抛棋子的最佳楼层，则n即为满足下列不等式的最小自然数

**`1+2+3+...+(n-1)+n   >=   floors`**

例如，当楼层数floors=39时，上述不等式的解是9 
当楼层数floors=100时，上述不等式的解是14。则此时，每次抛下的楼层数分别是14，27,39,50,60,69,77,83,88,92,95,97,98。 



## 反馈与建议
- 邮箱：<lbs1203940926@163.com>
- 微信：[@脱缰的哈士奇(ab1203940926)](http://ojx8u3g1z.bkt.clouddn.com/wechat-id.jpg)
- 微博：[@脱缰的哈士](http://weibo.com/2329754491/profile) 